# Chapter 3 — Basic Tools

## The Editor
- Your editor is your main tool — master it completely.
- Know all shortcuts and tricks so editing feels like thinking, not typing.
- Vim (with extensions) is powerful enough for almost everything.

## Version Control
- Use version control for *everything* — not just code.
- Keeps a history, supports reversibility, and lets you safely explore.
- Use `git bisect` (binary chop) to find when bugs were introduced.
- A local Git repo is fine — you don’t need GitHub for it to be valuable.

## Debugging
- **Fix the problem, not the blame.**
- **Don’t panic.** Stay calm and methodical.
- **Failing test first** — reproduce before fixing.
- **Read the damn error message.**
- **Binary chop** — narrow down by halving inputs or code paths.
- **Rubber ducking** — explain the bug out loud; it clarifies your thinking.
- **It’s probably you, not the library.**

### Debugging Checklist
- Root cause or symptom?
- Framework/OS or your code?
- Tests complete enough?
- Could similar bugs exist elsewhere?

## Text Manipulation
- Be fluent in a language for quick text transformations (Python, Ruby, AWK, sed).
- Automate small, messy jobs — converting formats, cleaning data, renaming, etc.
- Text is the universal interface — master it and you can automate almost anything.

## Engineering Daybook
- Keep a daily log for ideas, debugging values, or quick notes.
- Works like a rubber duck; clarifies your thinking.
- Builds a personal history of progress and insight.
- Don’t curate — it’s for you, not for show.

## Core Message
> Tools amplify thought. The sharper your tools and habits, the more effectively you can build, debug, and grow as an engineer.
